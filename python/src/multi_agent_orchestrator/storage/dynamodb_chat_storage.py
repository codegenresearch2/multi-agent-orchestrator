from typing import List, Dict, Optional, Union\\\\\nimport time\\\nimport boto3\\\nfrom multi_agent_orchestrator.storage import ChatStorage\\\nfrom multi_agent_orchestrator.types import ConversationMessage, TimestampedMessage, ParticipantRole\\\nfrom multi_agent_orchestrator.utils import Logger, conversation_to_dict\\\n\\\nclass DynamoDbChatStorage(ChatStorage):\\\\\n    def __init__(self, table_name: str, region: str, ttl_key: Optional[str] = None, ttl_duration: int = 3600):\\\\\n        super().__init__()\\\\\n        self.table_name = table_name\\\\\n        self.ttl_key = ttl_key\\\\\n        self.ttl_duration = ttl_duration\\\\\n        self.dynamodb = boto3.resource('dynamodb', region_name=region)\\\n        self.table = self.dynamodb.Table(table_name)\\\n\\\n    async def save_chat_message(self, user_id: str, session_id: str, agent_id: str, new_message: ConversationMessage, max_history_size: Optional[int] = None) -> List[ConversationMessage]:\\\\\n        key = self._generate_key(user_id, session_id, agent_id)\\\n        existing_conversation = await self.fetch_chat_with_timestamp(user_id, session_id, agent_id)\\\n\\\n        if self.is_consecutive_message(existing_conversation, new_message):\\\\\n            Logger.debug(f'> Consecutive {new_message.role} message detected for agent {agent_id}. Not saving.')\\\n            return existing_conversation\\\\\n\\\n        timestamped_message = TimestampedMessage(\\\n            role=new_message.role,\\\n            content=new_message.content,\\\n            timestamp=int(time.time() * 1000)\\\n        )\\\n        existing_conversation.append(timestamped_message)\\\n        trimmed_conversation = self.trim_conversation(existing_conversation, max_history_size)\\\n\\\n        item = {\\\n            'PK': user_id,\\\n            'SK': key,\\\n            'conversation': conversation_to_dict(trimmed_conversation)\\\n        }\\\\n\\\n        if self.ttl_key:\\\\\n            item[self.ttl_key] = int(time.time()) + self.ttl_duration\\\\n\\\n        try:\\\\\n            self.table.put_item(Item=item)\\\n        except Exception as error:\\\\\n            Logger.logger.error(f'Error saving conversation to DynamoDB: {str(error)}')\\\n            raise\\\\n\\\n        return self._remove_timestamps(trimmed_conversation)\\\\n\\\n    async def fetch_chat(self, user_id: str, session_id: str, agent_id: str) -> List[ConversationMessage]:\\\\\n        key = self._generate_key(user_id, session_id, agent_id)\\\n        try:\\\\\n            response = self.table.get_item(Key={'PK': user_id, 'SK': key})\\\\\n            stored_messages = self._dict_to_conversation(response.get('Item', {}).get('conversation', []))\\\\\n            return self._remove_timestamps(stored_messages)\\\\\n        except Exception as error:\\\\\n            Logger.logger.error(f'Error getting conversation from DynamoDB: {str(error)}')\\\n            raise\\\\n\\\n    async def fetch_chat_with_timestamp(self, user_id: str, session_id: str, agent_id: str) -> List[TimestampedMessage]:\\\\\n        key = self._generate_key(user_id, session_id, agent_id)\\\n        try:\\\\\n            response = self.table.get_item(Key={'PK': user_id, 'SK': key})\\\\\n            stored_messages = self._dict_to_conversation(response.get('Item', {}).get('conversation', []))\\\\\n            return stored_messages\\\\\n        except Exception as error:\\\\\n            Logger.logger.error(f'Error getting conversation from DynamoDB: {str(error)}')\\\n            raise\\\\n\\\n    async def fetch_all_chats(self, user_id: str, session_id: str) -> List[ConversationMessage]:\\\\\n        try:\\\\\n            response = self.table.query(\\\n                KeyConditionExpression='PK = :pk AND begins_with(SK, :skPrefix)',\\\\n                ExpressionAttributeValues={\\\n                    ':pk': user_id,\\\n                    ':skPrefix': f'{session_id}#'\\\\n                }\\\\n            )\\\n\\\n            if not response.get('Items'):\\\\\n                return []\\\\n\\\n            all_chats = []\\\\n            for item in response['Items']:\\\\\n                if not isinstance(item.get('conversation'), list):\\\\\n                    Logger.logger.error(f'Unexpected item structure: {item}')\\\\\n                    continue\\\\n\\\n                agent_id = item['SK'].split('#')[1]\\\\\n                for msg in item['conversation']:\\\\\n                    content = msg['content']\\\\\n                    if msg['role'] == ParticipantRole.ASSISTANT.value:\\\\\n                        text = content[0]['text'] if isinstance(content, list) else content\\\\\n                        content = [{'text': f'[{agent_id}] {text}'}]\\\\\n                    elif not isinstance(content, list):\\\\\n                        content = [{'text': content}]\\\\\n\\\n                    all_chats.append(\\\n                        TimestampedMessage(\\\n                            role=msg['role'],\\\n                            content=content,\\\n                            timestamp=int(msg['timestamp'])\\\\\n                        )\\\n                    )\\\\\n\\\n            all_chats.sort(key=lambda x: x.timestamp)\\\\\n            return self._remove_timestamps(all_chats)\\\\\n        except Exception as error:\\\\\n            Logger.logger.error(f'Error querying conversations from DynamoDB: {str(error)}')\\\n            raise\\\\n\\\n    def _generate_key(self, user_id: str, session_id: str, agent_id: str) -> str:\\\\\n        return f'{session_id}#{agent_id}'\\\\\n\\\n    def _remove_timestamps(self, messages: List[TimestampedMessage]) -> List[ConversationMessage]:\\\\\n        return [ConversationMessage(role=message.role, content=message.content) for message in messages]\\\\\n\\\n    def _dict_to_conversation(self, messages: List[Dict]) -> List[TimestampedMessage]:\\\\\n        return [TimestampedMessage(role=msg['role'], content=msg['content'], timestamp=msg['timestamp']) for msg in messages]\\\\\n