from typing import Dict, Any, AsyncIterable, Optional, Union\\nfrom dataclasses import dataclass, fields, asdict, replace\\nimport time\\nfrom multi_agent_orchestrator.utils.logger import Logger\\nfrom multi_agent_orchestrator.types import ConversationMessage, ParticipantRole, OrchestratorConfig\\nfrom multi_agent_orchestrator.classifiers import (Classifier, ClassifierResult, BedrockClassifier, BedrockClassifierOptions)\\\nfrom multi_agent_orchestrator.agents import (Agent, AgentResponse, AgentProcessingResult, BedrockLLMAgent, BedrockLLMAgentOptions)\\\nfrom multi_agent_orchestrator.storage import ChatStorage, InMemoryChatStorage\\n\\nDEFAULT_CONFIG = OrchestratorConfig()\\n\\n@dataclass\\nclass MultiAgentOrchestrator: \\n    def __init__(self, options: OrchestratorConfig = DEFAULT_CONFIG, storage: ChatStorage = InMemoryChatStorage(), classifier: Classifier = BedrockClassifier(options=BedrockClassifierOptions()), logger: Logger = None):\\n        if options is None: \\n            options = {} \\n        if isinstance(options, dict): \\n            valid_keys = {f.name for f in fields(OrchestratorConfig)} \\n            options = {k: v for k, v in options.items() if k in valid_keys} \\n            options = OrchestratorConfig(**options) \\n        elif not isinstance(options, OrchestratorConfig): \\n            raise ValueError("options must be a dictionary or an OrchestratorConfig instance") \\n\\n        self.config = replace(DEFAULT_CONFIG, **asdict(options)) \\n        self.storage = storage \\n        self.logger = Logger(self.config, logger) \\n        self.agents: Dict[str, Agent] = {} \\n        self.classifier: Classifier = classifier \\n        self.execution_times: Dict[str, float] = {} \\n        self.default_agent: Agent = BedrockLLMAgent(options=BedrockLLMAgentOptions(\\n            name="DEFAULT", \\n            streaming=True, \\n            description="A knowledgeable generalist capable of addressing a wide range of topics.", \\n        )) \\n\\n    def add_agent(self, agent: Agent): \\n        if agent.id in self.agents: \\n            raise ValueError(f"An agent with ID '{agent.id}' already exists.") \\n        self.agents[agent.id] = agent \\n        self.classifier.set_agents(self.agents) \\n\\n    def get_default_agent(self) -> Agent: \\n        return self.default_agent \\n\\n    def set_default_agent(self, agent: Agent): \\n        self.default_agent = agent \\n\\n    def set_classifier(self, intent_classifier: Classifier): \\n        self.classifier = intent_classifier \\n\\n    def get_all_agents(self) -> Dict[str, Dict[str, str]]: \\n        return {key: {"name": agent.name, "description": agent.description} for key, agent in self.agents.items()} \\n\\n    async def dispatch_to_agent(self, params: Dict[str, Any]) -> Union[ConversationMessage, AsyncIterable[Any]]: \\n        user_input = params['user_input'] \\n        user_id = params['user_id'] \\n        session_id = params['session_id'] \\n        classifier_result: ClassifierResult = params['classifier_result'] \\n        additional_params = params.get('additional_params', {}) \\n\\n        if not classifier_result.selected_agent: \\n            return """\\n            I'm sorry, but I need more information to understand your request. \\n            Could you please be more specific?\\n            """ \\n\\n        selected_agent = classifier_result.selected_agent \\n        agent_chat_history = await self.storage.fetch_chat(user_id, session_id, selected_agent.id) \\n\\n        self.logger.print_chat_history(agent_chat_history, selected_agent.id) \\n        #self.logger.info(f"Routing intent '{user_input}' to {selected_agent.id} ...") \\n\\n        response = await self.measure_execution_time(\n            f"Agent {selected_agent.name} | Processing request", \\n            lambda: selected_agent.process_request(user_input, user_id, session_id, agent_chat_history, additional_params) \\n        ) \\n\\n        return response \\n\\n    async def route_request(self, user_input: str, user_id: str, session_id: str, additional_params: Dict[str, str] = {}) -> AgentResponse: \\n        self.execution_times.clear() \\n        chat_history = await self.storage.fetch_all_chats(user_id, session_id) or [] \\n\\n        try: \\n            classifier_result: ClassifierResult = await self.measure_execution_time(\n                "Classifying user intent", \\n                lambda: self.classifier.classify(user_input, chat_history) \\n            ) \\n\\n            if self.config.LOG_CLASSIFIER_OUTPUT: \\n                self.print_intent(user_input, classifier_result) \\n\\n        except Exception as error: \\n            self.logger.error("Error during intent classification:", error) \\n            return AgentResponse(\n                metadata=self.create_metadata(None, user_input, user_id, session_id, additional_params), \\n                output=self.config.CLASSIFICATION_ERROR_MESSAGE, \\n                streaming=False \\n            ) \\n\\n        if not classifier_result.selected_agent: \\n            if self.config.USE_DEFAULT_AGENT_IF_NONE_IDENTIFIED: \\n                classifier_result = self.get_fallback_result() \\n                self.logger.info("Using default agent as no agent was selected") \\n            else: \\n                return AgentResponse(\n                    metadata= self.create_metadata(classifier_result, user_input, user_id, session_id, additional_params), \\n                    output= self.config.NO_SELECTED_AGENT_MESSAGE, \\n                    streaming=False \\n                ) \\n\\n        try: \\n            agent_response = await self.dispatch_to_agent({\n                "user_input": user_input, \\n                "user_id": user_id, \\n                "session_id": session_id, \\n                "classifier_result": classifier_result, \\n                "additional_params": additional_params \\n            }) \\n\\n            metadata = self.create_metadata(classifier_result, user_input, user_id, session_id, additional_params) \\n\\n            # save question \\n            await self.save_message(\n                ConversationMessage(\n                    role=ParticipantRole.USER.value, \\n                    content=[{'text': user_input}] \\n                ), user_id, session_id, classifier_result.selected_agent) \\n\\n            if isinstance(agent_response, ConversationMessage): \\n                # save the response \\n                await self.save_message(agent_response, user_id, session_id, classifier_result.selected_agent) \\n\\n            return AgentResponse(\n                    metadata=metadata, \\n                    output=agent_response, \\n                    streaming=False \\n                ) \\n\\n        except Exception as error: \\n            self.logger.error("Error during agent dispatch or processing:", error) \\n            return AgentResponse(\n                    metadata= self.create_metadata(classifier_result, user_input, user_id, session_id, additional_params), \\n                    output= self.config.GENERAL_ROUTING_ERROR_MSG_MESSAGE, \\n                    streaming=False \\n                ) \\n\\n        finally: \\n            self.logger.print_execution_times(self.execution_times) \\n\\n    def print_intent(self, user_input: str, intent_classifier_result: ClassifierResult) -> None: \\n        """Print the classified intent.""" \\n        Logger.log_header('Classified Intent') \\n        Logger.logger.info(f"> Text: {user_input}") \\n        Logger.logger.info(f"> Selected Agent: {intent_classifier_result.selected_agent.name if intent_classifier_result.selected_agent else 'No agent selected'}") \\n        Logger.logger.info(f"> Confidence: {intent_classifier_result.confidence:.2f}") \\n        Logger.logger.info('')""" \\n\\n    async def measure_execution_time(self, timer_name: str, fn): \\n        if not self.config.LOG_EXECUTION_TIMES: \\n            return await fn() \\n\\n        start_time = time.time() \\n        self.execution_times[timer_name] = start_time \\n\\n        try: \\n            result = await fn() \\n            end_time = time.time() \\n            duration = end_time - start_time \\n            self.execution_times[timer_name] = duration \\n            return result \\n        except Exception as error: \\n            end_time = time.time() \\n            duration = end_time - start_time \\n            self.execution_times[timer_name] = duration \\n            raise error \\n\\n    def create_metadata(self, intent_classifier_result: Optional[ClassifierResult], user_input: str, user_id: str, session_id: str, additional_params: Dict[str, str]) -> AgentProcessingResult: \\n        base_metadata = AgentProcessingResult(\n            user_input=user_input, \\n            agent_id="no_agent_selected", \\n            agent_name="No Agent", \\n            user_id=user_id, \\n            session_id=session_id, \\n            additional_params=additional_params \\n        ) \\n\\n        if not intent_classifier_result or not intent_classifier_result.selected_agent: \\n            base_metadata.additional_params['error_type'] = 'classification_failed' \\n        else: \\n            base_metadata.agent_id = intent_classifier_result.selected_agent.id \\n            base_metadata.agent_name = intent_classifier_result.selected_agent.name \\n\\n        return base_metadata \\n\\n    def get_fallback_result(self) -> ClassifierResult: \\n        return ClassifierResult(selected_agent=self.get_default_agent(), confidence=0) \\n\\n    async def save_message(self, message: ConversationMessage, user_id: str, session_id: str, agent: Agent): \\n        if agent and agent.save_chat: \\n            return await self.storage.save_chat_message(user_id, session_id, agent.id, message, self.config.MAX_MESSAGE_PAIRS_PER_AGENT) \\n